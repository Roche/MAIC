---
title: "Matching-Adjusted Indirect Comparison: introduction and unanchored example of the <tt>MAIC</tt> package"
author: "Roche"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    number_sections: true
bibliography: references.bib
csl: biomedicine.csl
vignette: >
  %\VignetteIndexEntry{Matching-Adjusted Indirect Comparison: introduction and unanchored example of the <tt>MAIC</tt> package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


<style type="text/css">

body{ /* Normal  */
      font-size: 14px;
}
td {  /* Table  */
  font-size: 10px;
}
h1.title {
  font-size: 38px;
}
h1 { /* Header 1 */
  font-size: 28px;
  }
h2 { /* Header 2 */
    font-size: 22px;
}
h3 { /* Header 3 */
  font-size: 18px;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 6, message = FALSE, warning = FALSE
)
```

# Introduction

This package describes the steps required to perform a matching-adjusted indirect comparison (MAIC) analysis using the <tt>MAIC</tt> package in R where the endpoint of interest is either time-to-event (e.g. overall survival) or binary (e.g. objective tumor response).

The methods described in this document are based on those originally described by Signorovitch et al. 2010 and described in the National Institute for Health and Care Excellence (NICE) Decision Support Unit (DSU) Technical Support Document (TSD) 18. [@signorovitch2010; @phillippo2016a]

MAIC methods are often required when: 

* There is no common comparator treatment to link a clinical trial of a new intervention to clinical trials of other treatments in a given disease area. For example if the only study of a new intervention is a single arm trial with no control group. This is commonly referred to as an unanchored MAIC.
* A common comparator is available to link a clinical trial of a new intervention to a clinical trial of one other treatment in a given disease area but there are substantial differences in patient demographic or disease characteristics that are believed to be treatment effect modifiers. This is commonly referred to as an anchored MAIC.

The premise of MAIC methods is to adjust for between-trial differences in patient demographic or disease characteristics at baseline. When a common treatment comparator or ‘linked network’ are unavailable, a MAIC assumes that differences between absolute outcomes that would be observed in each trial are entirely explained by imbalances in prognostic variables and treatment effect
modifiers. Prognostic variables are those that are predictive of disease outcomes, independent of the treatment received. For example, older patients may have increased risk of death compared to younger patients. Treatment effect modifiers are those variables that influence the relative effect of one treatment compared to another. For example patients with a better performance status may experience a larger treatment benefit than those with a worse performance status. Under this assumption, every prognostic variable and every treatment effect modifier that is imbalanced between the two studies must be available. This assumption is generally considered very difficult to
meet. [@phillippo2016a] There are several ways of identifying prognostic variables/treatment effect modifiers to be used in the MAIC analyses, some of which include:

* Clinical expertise (when available to a project)
* Published papers/previous submissions (what has been identified in the disease area previously)
* Univariable/multivariable regression analyses to identify which covariates have a significant effect on the outcome
* Subgroup analyses of clinical trials may identify interactions between patient characteristics and the relative treatment effect


# Theory behind MAIC

We will briefly go over the theory behind MAIC. For detailed information, see Signorovitch et al.  [@signorovitch2010] 

Let us define $t_i$ to be the treatment patient $i$ received. We assume $t_i=0$ if the patient received intervention (IPD) and $t_i=1$ if the patient received comparator treatment. The causal effect of treatment $T=0$ vs $T=1$ on the mean of the outcome $Y$ can be estimated as below

\[
\frac{\sum_{i=1}^{n}y_{i}(1-t_{i})w_{i}}{\sum_{i=1}^{n}(1-t_{i})w_{i}}-\bar{y}_{1}
\]

where $w_i=\frac{Pr(T_i=1\mid x_i)}{Pr(T_i=0\mid x_i)}$ is the odds that patient $i$ received treatment $T=1$ vs $T=0$ (i.e. enrolls in aggregate data study vs IPD study) given baseline characteristics $x_i$. Thus, the patients receiving $T=0$ are re-weighted to match the distribution of patients receiving $T=1$. Note that this causal effect would be the case when the outcome $Y$ is continuous. If the outcome is binary, $Y$ would be a proportion and we would use a link function such as logit to give us the causal effect in an odds ratio scale. As in propensity score methods, we may assume $w_i$ to follow logistic regression form

\[
w_{i}=exp(x_{i}\beta)
\]

However, in order to estimate $\beta$, we cannot use maximum likelihood approach because we do not have IPD for both trials. Instead, we use method of moments. We estimate $\beta$ such that the weighted averages of the covariates in the IPD exactly matches the aggregate data averages. Mathematically speaking, we want to estimate $\beta$ such that:

\[
0=\frac{\sum_{i=1}^{n}x_{i}exp(x_i\hat{\beta})}{\sum_{i=1}^{n}exp(x_i\hat{\beta})}-\bar{x}_{agg}
\]

If the $x_i$ contains all confounders and the logistic regression for $w_i$ is correctly specified, we obtain a consistent estimate of the causal effect of intervention vs comparator treatment. Above equation is equivalent to

\[
0=\sum_{i=1}^{n}(x_{i}-\bar{x}_{agg})exp(x_{i}^{T}\hat{\beta})
\]

We could transform transform IPD by subtracting the aggregate data means (this is why centering is needed when preprocessing). 

\[
0=\sum_{i=1}^{n}x_{i}exp(x_{i}^{T}\hat{\beta})
\]

Note that this is the first derivative of

\[
Q(\beta)=\sum_{i=1}^{n}exp(x_{i}^{T}\hat{\beta})
\]

which has second derivative

\[
Q''(\beta)=\sum_{i=1}^{n}x_ix_i^Texp(x_{i}^{T}\hat{\beta})
\]

Since $Q''(\beta)$ is positive-definite for all $\beta$, $Q(\beta)$ is convex and any finite solution from the equation is unique and corresponds to the global minimum of $Q(\beta)$. Thus, we can use optimization methods to calculate $\beta$.

# Example scenario

We present an unanchored MAIC of two treatments in lung cancer with the treatments being compared labelled 'intervention' and 'comparator'. The two endpoints being compared are overall survival (a time to event outcome) and objective response (a binary outcome). The data used in this example have been simulated to resemble that of clinical trial data. The data available are:

* Individual patient data from a single arm study of 'intervention'
* Aggregate summary data for 'comparator'. This could be from a single arm study of the comparator or from one arm of a randomized controlled trial.
* Psuedo patient data from the comparator study. This is not required for the matching process but is needed to derive the relative treatment effects between the intervention and comparator.

In this example scenario, age, sex, the Eastern Cooperative Oncology Group performance status (ECOG), smoking status, and number of previous treatments have been identified as imbalanced prognostic variables/treatment effect modifiers.

# Preprocessing

## Load required R packages

```{r}
#devtools::install_github("roche/MAIC")
library(MAIC)

library(dplyr)
library(survival) # for survfit
library(survminer) # for ggsurvplot
library(boot) # for boot
```

## Intervention trial IPD

This example reads in and combines data from three standard simulated data sets (adsl, adrs and adtte) which are saved as '.csv' files. The data may need some manipulation to standardize the variable names to ensure they are the same in all datasets.

The variables needed for the time to event analyses are:

* Time - a numeric variable
* Event - a binary variable (event=1, censor=0)
* Treatment - a character variable with the name of the intervention treatment 

The variables needed for the binary event analyses are:

* Response - a binary variable (event=1, no event=0)
* Treatment - a character variable with the name of the intervention treatment

For the matching variables:

* All binary variables to be used in the matching should be coded 1 and 0 (see example for sex below).
* The variable names need to be listed in a character vector called
<tt>match_cov</tt>.

```{r}
# Read in relevant ADaM data
adsl <- read.csv(system.file("extdata", "adsl.csv", package = "MAIC",
                             mustWork = TRUE))
adrs <- read.csv(system.file("extdata", "adrs.csv", package = "MAIC",
                             mustWork = TRUE))
adtte <- read.csv(system.file("extdata", "adtte.csv", package = "MAIC",
                              mustWork = TRUE))

adsl <- adsl %>% # Data containing the matching variables
  mutate(SEX=ifelse(SEX=="Male", 1, 0)) %>% # Coded 1 for males and 0 for females
  mutate(AGE_SQUARED = AGE^2) # Create a variable for age squared
  
adrs <- adrs %>% # Response data
  filter(PARAM=="Response") %>%
  transmute(USUBJID, ARM, response=AVAL)

adtte <- adtte %>% # Time to event data (overall survival)
  filter(PARAMCD=="OS") %>%
  mutate(EVENT=1-CNSR) %>% #Set up coding as Event = 1, Censor = 0
  transmute(USUBJID, ARM, TIME=AVAL, EVENT)

# Combine all intervention data
intervention_input <- adsl %>%
  full_join(adrs, by=c("USUBJID", "ARM")) %>%
  full_join(adtte, by=c("USUBJID", "ARM"))

# Change to lower case
names(intervention_input) <- tolower(names(intervention_input))
head(intervention_input)

# Define variables you intend to match with
match_cov <- c("age", "age_squared", "sex", "smoke", "ecog0", "n_pr_ther")
```

## Baseline data from the comparator trial

The aggregate baseline characteristics from the comparator trial are needed as a data frame. Possible characteristics include mean, median, or standard deviation of continuous variables and proportion for binary variables. For continuous variables, only a single summary measure of mean or median can be provided and if standard deviation is provided, mean also needs to be specified. Possible missingness of binary varibles should be accounted for by subtracting the denominator by the missing count i.e. proportion = count / (N - missing).

The naming of comparator trial needs to be consistent with the IPD data variable name. The naming should be followed by the following suffixes accordingly: "_prop",  "_mean", "_median", "_sd". The R code below demonstrates some examples. 

```{r}
# Define example target population
target_pop <- data.frame(
  age_mean = 50.06,
  age_sd = 3.23,
  sex_prop = 147/300, #male proportion
  smoke_prop = 58/(300-2), #2 missing patients
  ecog0_prop = 105/300,
  n_pr_ther_median = 3 #median number of previous therapies
)
```

### How to handle standard deviation aggregate summary

As described by Phillippo et al., balancing on both mean and standard deviation for continuous variables (where possible) may be considered in some cases. [@phillippo2016a] If a standard deviation is provided in the comparator population, preprocessing is done so that in the target population, $E(X^2)$ is calculated using the variance formula $Var(X)=E(X^{2})-E(X)^{2}$. This $E(X^2)$ in the target population is matched with the IPD level data, which is why $X^{2}$ was calculated during the preprocessing stage of IPD.

### How to handle median aggregate summary

If a median is provided, IPD is preprocessed to categorize the variable into a binary variable. All the values in the IPD that are higher than the comparator population median is assigned a value of 1. Conversely, all values that are lower are assigned a value of 0. Comparator population median is replaced by 0.5 to adjust to the categorization in the IPD data. The newly created IPD binary variable is matched so that the proportion is 0.5.

### How to handle missing counts in aggregate data

Explain why.

## R code to preprocessing and center IPD

The following function <tt>preprocess_data</tt> is used to preprocess data and center the IPD data so that it is ready for calculating weights. Once the data is preprocessed, we remove the prefixes in the target population.

```{r}
preprocessed <- preprocess_data(intervention_input, target_pop)
intervention_data <- preprocessed$intervention_data
target_pop <- preprocessed$target_pop

head(intervention_data)
head(target_pop)
```

# Calculating weights

We use the <tt>estimate_weights</tt> function which uses <tt>optim</tt> function in the <tt>stats</tt> library to optimize weights.

```{r}
weights <- estimate_weights(intervention_data = intervention_data,
                            matching_vars = match_cov)
str(weights)
intervention_data <- intervention_data %>%
  mutate(wt = weights$analysis_data$wt, ARM = "Intervention")
head(intervention_data)
```





